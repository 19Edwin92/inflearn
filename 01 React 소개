제1강

01 리액트는 무엇인가? 
리액트 공식사이트에서는 사용자 인터페이스를 위한 자바스크립트 라이브러리이다. 
여기서 라이브러리란 자주사용되는 기능들을 모아놓은 모음집을 말한다. 

사용자인터페이스(UI) 컴퓨터와 사용자 사이의 정보를 위한 창구이다. 
대표적인 것이 버튼을 통해서 사용자가 입력한 정보들의 소통이 이뤄지는 환경을 말한다. 
리액트는 이러한 UI 라이브러리 가운데 대표적인 하나의 모음집니다.  

- NGULARJS는 현재 지원종료(프레임워크) - 제어권한이 프레임워크에게 있다
- React 가장 유명한 라이브러리 - 제어권한이 개발자에게 있다.(현재, 핫하지만 언젠가 대체될 수 있다.)
- Vue 요즘 뜨는 라이브러리 - 제어권한이 개발자에게 있다.

SPA - Single Page Apprication 단일 페이지 애플리케이션
무수한 HTML을 양산하여 만든 웹페이지가 아니라 하나의 페이지에서 블록(컴포넌트)들로 내부를 디자인하며
화면을 구축하는 기술을 말하며, 리액트는 SPA를 만드는데 최적화된 라이브러리이다. 

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

02 리액트의 장점
첫째, 빠른 업데이트와 렌더링 속도 : 화면전환이 빠른 것을 말한다. 
리액트에서는 이를 위해서 Vitual DOM을 사용한다. 가상의 DOM이다. DOM은 웹페이지를 규정하는 객체이다. 
콘솔에 document를 검색하면 살펴볼 수 있다. Vitual DOM은 웹브라우저가 리렌더링 되었을 때, 전체를 변경하는 것이 아니라 필요한 부분만 수정하기에 빠른 방식으로 동작한다. 

둘재, 컴포넌트 기반
리액트에는 컴포넌트(구성요소)로 구성되어 있으며, 마치 미니 레고블록으로 만드는 것을 볼 수 있다. 
에이비엔비의 경우 A컴포넌트의 반복과 B컴포넌트의 반복으로 구성된다. 

이는 "재사용성"을 극대화한 것인데, 이는 전체 소프트웨어의 개발 기간이 단축된다는 이점이 있다. 
또한 유지 보수가 용이해진다는 점이다. 공통모듈이 문제가 되면 이 모델만 수정하면 되기 때문이다. 

리액트 역시 하나의 컴포넌트는 재사용성을 지원한다는 것이다. 

셋째, 든든한 지원군 Meta
오픈소스프로젝트이지만, 리액트는 Meta에서 시작한 프로젝트이며, 지속적인 관리를 받고 있다. 
Meta에서 프로젝트를 종료하지 않을 때까지 지속될 것 같다는 점이다. 
또한 활발한 지식공유와 커뮤니티가 존재한다는 것이기에, 바로 찾아서 볼 수 있다는 것이다. 

----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------

03 리액트의 단점
리액트는 배워야 할 새로운 개념들이 많이 등장한다는 점이다. 그리고 계속 무언가 변환되기에 새로운 개념들이 계속 등장한다. 
그리고 이를 배워야 실무에서 사용할 수 있다. 

또한 높은 상태관리 복잡도(state) 때문에 그렇다. 성능최적화를 위해서는 state가 중요한데, 이 관리가 복잡하다. 

----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------

2강은 HTML만으로 폴더의 index.html 에 기록해두었다. 해당부분으로 이동.

----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------

01 create-react-app : cra
위 index.html으로 실습한 내용은 html에서 직접 React를 실행한 것이지만, 보통 웹사이트를 제작할 때에는 이러한 방식이 아니라,
cra를 통해서 직접 리액트 환경을 구축한다. 

이를 위해서는 Node.js v.14 npm 페키지를 설치해야 한다. 
터미널 : npx create-react-app 프로젝트명

----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------

03-1강 JSX 문법
JavaScript & Xml/HTML : 자바스크립트의 확장 문법을 뜻한다.  
const element = <h1>hello, world!</h1>;

대입연산자 왼쪽은 자바스크립트인데
오른쪽을 보면, HTMl 인 것을 볼 수 있다. 

대입된 값으로 HTML을 조작하는 것이다. 


그렇다면, JSX의 역할은 무엇일까? HTML을 자바스크립트로 변환하는 것이다. 이를 변환하는 것이 React.createElement 이다. 
 
React.createElement (소괄호) 안에 기록되는데 3가지 이다. 1) type, 2) [props] 3) [...childern]
이전 강의에서 버튼을 만들었던 내용과 함께 살펴보자. 

    #JSX를 사용한 코드
    const element = (
      <h1 className="greeting"> Hello, world!</h1> 
    )

    #JSX를 사용하지 않는 코드
    const element = React.createElement(
      'h1',
      {className: 'greeting'},
      'Hello, world'
    )

    #위의 동일한 2개의 코드의 결과로, 자바스크립트는 아래의 객체를 생성한다. 함수명이 create 'Element'
    const element = {
      type: 'h1',          // HTML의 태그
      props: {             // HTML 태그의 속성
              className: 'greeting',         
              childern: 'Hello, world!'    // Element가 가지고 있는 자식 엘리먼트
      }
    }

JSX는 필수는 아니지만, 생성성과 가독성 때문에, 권장된다.     

----------------------------------------------------------------------------------------------------------------------------------------------------------
03-2강 JSX 장점
첫째, 코드가 간결해진다. 
둘째, 가독성이 향상된다. 코드 상의 버그를 쉽게 발경한 수 있다. 

    #JSX사용
    <div> hello, {name} </div>
 
    #JSX 사용하지 않음
    React.createElement('div', null, 'Hello, ${name}');

셋째, 보안성이 올라간다. injection Attacks 방어

05강 JSX 사용법 = 보든 자바스크립트 지원 
자바스크립트 = HTML 만약 이 영역에서 JS를 사용하고 싶다면 {중괄호}를 통해서 사용이 가능하며, 이 괄호에는 JS의 함수를 사용해도 된다. HTML을 사용하기에 부모태그와 자식태그를 기록했듯, div 태그 내에 다른 태그모음을 넣었던 것이 가능해진다는 말이다. 

    #작성해보기 
    chapter03 > Book.js 파일로 넘어가서 작업하자. 


04강 Element에 대해서 다뤄봅시다. 
element 요소/성분, 리액트의 요소에 대해서 공식홈페이지는 리액티 앱의 가장 작은 건축요소라고 한다. 
리액트 요소는, 화면에서 보이는 것들을 기술하는 것이다. 

    #JSX사용
    const element = <div> hello, {name} </div>

리액트 요소는 자바스트맄트 객체 형태로 존재한다. 

    #JSX를 사용하지 않는 코드
    const element = React.createElement(
      'h1',  #태그
      {className: 'greeting'}, #태그명
      'Hello, world' #태그의 innerText, 또는 하위 태그들
    )

04강 Element의 불변성
한 번 생성된 요소는, 생성 후에는 childern이나 속성을 바꿀 수 없다는 것이다. 화면에 새로운 내용을 보여주어야 한다면,
해당 내용만 변경하고, 이때 Virtual DOM은 이를 계산하고, 필요한 부분만 렌더링하여 보여주기에 빠른 렌더링이 가능한 것이다. 

    #Root DOM Node
    <div id="root"></div>

위에 작성된 부분은 간단하지만 중요하다. div[id="root"]는 Root DOM Node라고 불리는데, 리액트를 통해서 관리된다. 리액트를 통해서 만들었다면,
하나의 root에서 관리된다. 

    #Root DOM 연동하기
    const element = <h1>안녕, 리액트!</h1>
    ReactDOM.render(element, document.getelementById('root'));

첫번째 파라미터 : 가상 DOM
두번째 파라미터 : 실제브라우저에 존재하는 DOM    

기억합시다. 요소는 불변성을 가지기에, 변경하려먼 새로운 요소를 렌더링해야 합니다. setIner 로 초단위 변화를 주었다면, 새로 만들어서 덧붙이는 것임을 기억합니다. 

05강 실습하기, 시계를 만들어보자. 
  #강의내용 : 구독자님의 변경 react 18에 맞춰서 작성한 코드이다. 
  #매초 Clock 요소가 새롭게 생성되며 덧띄워질 것이다. 
  const root = ReactDOM.createRoot(document.getElementById('root'));
  setInterval(() => {
    root.render(
      <React.StrictMode>
        <Clock />
      </React.StrictMode>
    );
  })
  
  #강의내용 : ReactDOM.render 해당부분에 오류가 있어서 작동되지 않았다. ReactDOM이 아니라 현재 리액트에서 작업하고 있기 때문에 위와 같이 기록해야 한다. 
  setInterval(() => {
  ReactDOM.render(
    <React.StrictMode>
      <Clock />
    </React.StrictMode> 
    document.getElementById('root')
  );
})
  
----------------------------------------------------------------------------------------------------------------------------------------------------------
5강 컴포넌트와 프롭스에 대해서 배워보자. 
리액트에서는 모든 것이 컴포넌트로 구성되었고, 이를 조립하듯 컴포넌트들을 모아서 개발한다. 
작은 컴포넌트들이 하나의 구성을 
작은 컴포넌트들이 전체페이지를 구성하기 때문이다. 

리액트 컴포넌트에는 props(attribute)를 통해서 속성값을 주어 화면을 구동하게 할 수 있습니다. 
리액트 컴포넌트를 붕어빵 틀이라고 생각해봅시다. 요소들은 붕어빵 틀에 부어진 믹스를 통해서 구성되는 여러개의 요소들을 만들수 있듯이 말이죠. 

property 재산, 속성, 특성입니다. 바로 컴포턴트의 속성입니다. 
같은 틀이라도, 팥/슈트림/고구마 속성을 통해서 재미를 줄 수 있듯이, 속성값을 다르게 설정해 줄 수 있는데, 프롭스가 이러한 역할을 합니다. 
즉, 컴포넌트의 속 재료라고 합니다. 

그런데 props 는 READ-only 입니다. 읽기만 할 수 있습니다. 속을 바꾸고 싶다면, useState가 있는데 이것은 추후에
리액트 공식 사이트에서는 props를 이렇게 기록한다. 의역 : 모든 리액트 컴포넌트는 props를 직접 바꿀 수 없고, 같은 props에 대해서는 항상 같은 결과를 보여줄 것!

컴포넌트는 초기 class 를 사용했지만, 최근에는 function 을 사용하고 있으며, 이 과정에서 HOOK이 등장하게 되었습니다. 
pure Function 매개변수를 변경하지 않는 단지 결과로 송출하는 함수를 뜻합니다. 

  #예시를 봅시다.
  function Welcome(props) {
    return <h1>안년, {props.neme}</h1>
  }

  #Class 에시를 보자. ES6에서 등장하였다. 위의 모델과 동일합니다. 
  class Welcome extends React.Component {
    render() {
      return <h1> 안녕, {this.props.name}</h1>;
    }
  }

컴포넌트 이름을 작명할 때 규칙이 있는데, 항상 대문자로 시작해야 합니다. 그렇지 않으면 DOM으로 인식하기 때문입니다. 반면에 대문자는 리액트로 활용된다. 

  #DOM 태그와 리액트 컴포넌트의 차이
  const element = <div />;
  const element2 = <Welcome name="인제" />;

컴포넌트가 만들어졌다면, 렌더링은 어떻게 될까?
1) 컴포넌트에서 요소를 만들어 내야 한다. 

  #실제 문장을 보자
  function Welcome(props) {
    return <h1>안녕, {props.name}</h1>
  }

  const element = <Welcome name="인제" />
  #ReactDOM을 통해서 실재 DOM에 렌더린합니다. 
  ReactDOM.render(
    element,
    document.getElementById('root')
  )

리액트는 컴포넌트 안에 컴포넌트를 구성할 수 있다. 즉 App 컴포넌트와 Welcome 컴퍼넌트가 존재할 때,
App 컴포넌트 안에 각기 다른 props를 가진 Welcome 컴포넌트를 만들수 있다. 이럴 컴포넌트 합성이라고 한다. 

그리고 큰 컴포넌트에서 작은 조각을 추출하는 컴포넌트 추출을 할 수 도 있고, 이는 다른 곳에서 사용할 수 있는 재사용성을 높일 수 있다. 

재사용 가능한 컴포넌트가 많을 수록 개발 속도는 빨라지게 된다. 

----------------------------------------------------------------------------------------------------------------------------------------------------------
6강 State와 Lifecyle(class 컴포넌트에서 사용하고, function에서 쓰지 않음)
리액트에서의 State(컴포넌트의 데이터, 변경가능한 데이터) - 렌더링이나 데이터 흐름에 사용되는 값만 포함해야 한다. 
state는 JavaScript 객체이다. 

  #예제코드
  class LikeButton extends React.Component {
    constructor(props) {
      super(props);

      this.state = {
        liked: false
      }
    }
  }

constructor 생성자 함수가 있고, this.state 생성자를 정의하는 부분이다. function에서는 useState 에서 Hook을 사용한다. 
그런데 엄밀한 의미에서 state는 직접 수정할 수 없다.(하면 안된다.)

  #잘못된 경우(직접수정)
  this.state = {
        name: 'Inje'
  };

  #정상적인 수정방법
  this.setState = {
        name: 'Inje'
  };

setState 과 같이 수정해야 한다. 그렇지 않으면 개발자가 의도하지 않은 변경이 이뤄질 것이다. 

06-2강 Lifecyle 생명주기
컴포넌트의 생성과 소멸시점이 정해져 있다. 
- 출생 : 컨스트럭돌 : 렌더 : 업데이트 DOM : componentDidMount
- 인생 :           렌더 : 업데이트 DOM : componentDidUndate
- 사망 :                              conpoentWillUnmount : 화면에 더이상 표시하지 않게 될 때 

즉, 컴포넌트가 시간의 흐름에 따라 생성되고 업데이트 되다가 사라진다는 점이다. 

7강 HOOK, 리액트 16.3 버전에서 등장
컴포턴트는 함수형과 클래스가 있었고, 
클래스는 state가 있었고 setState() 함수를 통해서 state를 업데이트 했으며, Lifecycle methods를 제공받았다. 
그러나 함수형은 "state" 사용이 불가했고, Lifecycle에 따른 기능 구현이 불가했다. 이를 가능하게 하는 것이 Hooks이다. 

Hooks() 를 통해서 State사용할 수 있게 되었습니다. 
Use 라고 불려진 것이 HooKs이라는 것을 나타내주었습니다. 

(1) useState() : state를 사용하기 위한 Hook 이다. 

  #예제코드
  function Counter(props) {
    var count = 0;

    return (
      <div> 
        <p> 총 {count}번 클릭했습니다. </p>
        <button onClik={() => count++}> 클릭 </button>
      </div>
    )
  }

카운트를 변경하고 싶은데, 단일한 페이지에서는 새로고침이 되지 않아 이를 구현할 수 없다. 이를 위해서 useState를 사용한다. 
  #useState() 사용법
  const [변수명, set함수명] = useState(초기값); // 선언하면, 배열을 생성한다. 
                                          ;// 변수가 여러개라면, 변수 개수에 따라서 입력해주어야 한다.   

  #예제코드
  function Counter(props) {
    const [count, setCount] = useState(0);  

    return (
      <div> 
        <p> 총 {count}번 클릭했습니다. </p>
        <button onClik={() => setCount(count++)}> 클릭 </button>
        ; 보는 것과 같이 setCount(count++) 함수를 통해서 해당 내용의 값이 변경되는 것을 보자. 
      </div>
    )
  }

(2) useEffect() : Side effect(부작용)를 수행하기 위한 Hook
개발자가 의도치 않는 실행으로 버그가 발생되는 것을 말하지만, 리액트에서는 효과, 영향을 말한다. 
다른 컴포넌트에 영향을 미칠 수 있으며, 렌더링 중에는 작업이 실행되지 않기 때문에, Side에서 실행한다는 의미입니다. 
클래스의 생명주기의 기능을 구현할 수 있다. 

  #사용방법
  useEffect(이펙트 함수, 의존성 배열)
  ## 업데이트가 된 제 렌더링 이후에 의존성 배열이 변경되면 실행된다.  만약 mount,unmont 시 한 번씩 실행하고 싶다면 
  useEffect(이펙트 함수, []) ## 이와 같이 기록해주면 된다. 
  useEffect(이펙트 함수) ## 컴포넌트가 업데이트 될 때마다 사용된다. 

(4) useMemo() : Memoization 최적화를 실행하는 과정이다. 메모를 해두었다가 나중에 사용하는 것이다. 
결과적으로는 빠른 렌더링을 구현할 수 있다는 것이다. 의존성 배열을 넣지 않으면, 매 렌더링 때에만 사용된다. 

(4) useCallback() : 함수를 반환한다. useMemo()과 유사하는데 함수를 반환한다는 점에서 다르다. 

  #그러나 동일하게 구성하는 것도 가능한데,
  useCallback(함수, 의존성 배열);
  useMeno(()=> 함수, 의존성 배열)

(5) useRef() : 특정 컴포넌트에 접근할 수 있는 객체를 의미한다. 이 객체를 반홚나다.  
만약 내부의 데이터가 변경되었을 때 가르쳐 주지 않기에, Callback () 을 통해서 알림을 받을 수 있다. 

Hook의 규칙
1) 최상이 레벨에서만 호출해야 한다. 반복문/조건문에서는 사용할 수 없다. 
2) 리액트 함수 컴포넌트에서만 호출해야 한다. 
## eslint-plugin-reat-hooks : 플러그인인데, hook의 조건에 따라서 작성하도록 도와준다. 

Custom Hook 만들기
Hook을 만들 수도 있다. 이름이 use로 사작하면 된다. 사실 특별한 규칙이 없다. 매개변수와 인수를 정할 수 있지만, Hook을 사용해야 하며(use), 이 규칙을 따라야 한다. 

